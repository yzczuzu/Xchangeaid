import React from "react";
export declare function createDescendantContext<ElementType, DescendantProps = {}>(name: string, initialValue?: {}): React.Context<IDescendantContext<ElementType, DescendantProps>>;
/**
 * This hook registers our descendant by passing it into an array. We can then
 * search that array by to find its index when registering it in the component.
 * We use this for focus management, keyboard navigation, and typeahead
 * functionality for some components.
 *
 * The hook accepts the element node and (optionally) a key. The key is useful
 * if multiple descendants have identical text values and we need to
 * differentiate siblings for some reason.
 *
 * Our main goals with this are:
 *   1) maximum composability,
 *   2) minimal API friction
 *   3) SSR compatibility*
 *   4) concurrent safe
 *   5) index always up-to-date with the tree despite changes
 *   6) works with memoization of any component in the tree (hopefully)
 *
 * * As for SSR, the good news is that we don't actually need the index on the
 * server for most use-cases, as we are only using it to determine the order of
 * composed descendants for keyboard navigation. However, in the few cases where
 * this is not the case, we can require an explicit index from the app.
 */
export declare function useDescendant<ElementType, DescendantProps>({ context, element, ...rest }: Omit<Descendant<ElementType, DescendantProps>, "index"> & {
    context: React.Context<IDescendantContext<ElementType, DescendantProps>>;
}, indexProp?: number): number;
export declare function useDescendants<ElementType, DescendantProps = {}>(): [Descendant<ElementType, DescendantProps>[], React.Dispatch<React.SetStateAction<Descendant<ElementType, DescendantProps>[]>>];
export declare function DescendantProvider<ElementType, DescendantProps>({ context: Ctx, children, items, set, }: {
    context: React.Context<IDescendantContext<ElementType, DescendantProps>>;
    children: React.ReactNode;
    items: Descendant<ElementType, DescendantProps>[];
    set: React.Dispatch<React.SetStateAction<Descendant<ElementType, DescendantProps>[]>>;
}): JSX.Element;
/**
 * Testing this as an abstraction for compound components that use keyboard
 * navigation. Hoping this will help us prevent bugs and mismatched behavior
 * across various components, but it may also prove to be too messy of an
 * abstraction in the end.
 *
 * Currently used in:
 *   - Tabs
 *   - Accordion
 *
 * @param context
 * @param options
 */
export declare function useDescendantKeyDown<ElementType, DescendantProps = {}, K extends keyof Descendant<ElementType, DescendantProps> = keyof Descendant<ElementType, DescendantProps>>(context: React.Context<IDescendantContext<ElementType, DescendantProps>>, options: {
    currentIndex: number | null | undefined;
    key?: K | "option";
    filter?: (descendant: Descendant<ElementType, DescendantProps>) => boolean;
    orientation?: "vertical" | "horizontal" | "both";
    rotate?: boolean;
    rtl?: boolean;
    callback(nextOption: Descendant<ElementType, DescendantProps> | Descendant<ElementType, DescendantProps>[K]): void;
}): (event: React.KeyboardEvent<Element>) => void;
declare type SomeHTMLElement<T> = T extends HTMLElement ? T : HTMLElement;
export declare type Descendant<ElementType, DescendantProps = {}> = DescendantProps & {
    element: SomeHTMLElement<ElementType> | null;
    index: number;
};
export interface IDescendantContext<ElementType, DescendantProps> {
    descendants: Descendant<ElementType, DescendantProps>[];
    registerDescendant(descendant: Descendant<ElementType, DescendantProps>): void;
    unregisterDescendant(element: SomeHTMLElement<ElementType> | null): void;
}
export {};
