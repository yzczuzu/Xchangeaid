{"version":3,"file":"descendants.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["import React, { useCallback, useContext, useMemo, useState } from \"react\";\nimport {\n  createNamedContext,\n  noop,\n  useIsomorphicLayoutEffect,\n} from \"@reach/utils\";\n\nexport function createDescendantContext<ElementType, DescendantProps = {}>(\n  name: string,\n  initialValue = {}\n) {\n  return createNamedContext(name, {\n    descendants: [],\n    registerDescendant: noop,\n    unregisterDescendant: noop,\n    ...initialValue,\n  } as IDescendantContext<ElementType, DescendantProps>);\n}\n\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\nexport function useDescendant<ElementType, DescendantProps>(\n  {\n    context,\n    element,\n    ...rest\n  }: Omit<Descendant<ElementType, DescendantProps>, \"index\"> & {\n    context: React.Context<IDescendantContext<ElementType, DescendantProps>>;\n  },\n  indexProp?: number\n) {\n  let [, forceUpdate] = useState();\n  let { registerDescendant, unregisterDescendant, descendants } = useContext(\n    context\n  );\n\n  // Prevent any flashing\n  useIsomorphicLayoutEffect(() => {\n    if (!element) forceUpdate({});\n    // @ts-ignore\n    registerDescendant({ element, ...rest });\n    return () => unregisterDescendant(element);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [element, ...Object.values(rest)]);\n\n  return indexProp ?? descendants.findIndex(item => item.element === element);\n}\n\nexport function useDescendants<ElementType, DescendantProps = {}>() {\n  return useState<Descendant<ElementType, DescendantProps>[]>([]);\n}\n\nexport function DescendantProvider<ElementType, DescendantProps>({\n  context: Ctx,\n  children,\n  items,\n  set,\n}: {\n  context: React.Context<IDescendantContext<ElementType, DescendantProps>>;\n  children: React.ReactNode;\n  items: Descendant<ElementType, DescendantProps>[];\n  set: React.Dispatch<\n    React.SetStateAction<Descendant<ElementType, DescendantProps>[]>\n  >;\n}) {\n  let registerDescendant = React.useCallback(\n    ({ element, ...rest }: Descendant<ElementType, DescendantProps>) => {\n      if (!element) {\n        return;\n      }\n\n      set(items => {\n        let newItem: Descendant<ElementType, DescendantProps>;\n        let newItems: Descendant<ElementType, DescendantProps>[];\n        // If there are no items, register at index 0 and bail.\n        if (items.length === 0) {\n          newItem = {\n            element,\n            index: 0,\n            ...rest,\n          } as Descendant<ElementType, DescendantProps>;\n          newItems = [...items, newItem];\n        } else if (items.find(item => item.element === element)) {\n          // If the element is already registered, just use the same array\n          newItems = items;\n        } else {\n          // When registering a descendant, we need to make sure we insert in\n          // into the array in the same order that it appears in the DOM. So as\n          // new descendants are added or maybe some are removed, we always know\n          // that the array is up-to-date and correct.\n          //\n          // So here we look at our registered descendants and see if the new\n          // element we are adding appears earlier than an existing descendant's\n          // DOM node via `node.compareDocumentPosition`. If it does, we insert\n          // the new element at this index. Because `registerDescendant` will be\n          // called in an effect every time the descendants state value changes,\n          // we should be sure that this index is accurate when descendent\n          // elements come or go from our component.\n          let index = items.findIndex(item => {\n            if (!item.element || !element) {\n              return false;\n            }\n            // Does this element's DOM node appear before another item in the\n            // array in our DOM tree? If so, return true to grab the index at\n            // this point in the array so we know where to insert the new\n            // element.\n            return Boolean(\n              item.element.compareDocumentPosition(element) &\n                Node.DOCUMENT_POSITION_PRECEDING\n            );\n          });\n\n          newItem = {\n            element,\n            index,\n            ...rest,\n          } as Descendant<ElementType, DescendantProps>;\n\n          // If an index is not found we will push the element to the end.\n          if (index === -1) {\n            newItems = [...items, newItem];\n          } else {\n            newItems = [\n              ...items.slice(0, index),\n              newItem,\n              ...items.slice(index),\n            ];\n          }\n        }\n        return newItems.map((item, index) => ({ ...item, index }));\n      });\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  let unregisterDescendant = useCallback(\n    (element: Descendant<ElementType>[\"element\"]) => {\n      if (!element) {\n        return;\n      }\n\n      set(items => items.filter(item => element !== item.element));\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const value: IDescendantContext<\n    ElementType,\n    DescendantProps\n  > = useMemo(() => {\n    return {\n      descendants: items,\n      registerDescendant,\n      unregisterDescendant,\n    };\n  }, [items, registerDescendant, unregisterDescendant]);\n\n  return <Ctx.Provider value={value}>{children}</Ctx.Provider>;\n}\n\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\nexport function useDescendantKeyDown<\n  ElementType,\n  DescendantProps = {},\n  K extends keyof Descendant<ElementType, DescendantProps> = keyof Descendant<\n    ElementType,\n    DescendantProps\n  >\n>(\n  context: React.Context<IDescendantContext<ElementType, DescendantProps>>,\n  options: {\n    currentIndex: number | null | undefined;\n    key?: K | \"option\";\n    filter?: (descendant: Descendant<ElementType, DescendantProps>) => boolean;\n    orientation?: \"vertical\" | \"horizontal\" | \"both\";\n    rotate?: boolean;\n    rtl?: boolean;\n    callback(\n      nextOption:\n        | Descendant<ElementType, DescendantProps>\n        | Descendant<ElementType, DescendantProps>[K]\n    ): void;\n  }\n) {\n  let { descendants } = useContext(context);\n  let {\n    callback,\n    currentIndex,\n    filter,\n    key = \"index\" as K,\n    orientation = \"vertical\",\n    rotate = true,\n    rtl = false,\n  } = options;\n  let index = currentIndex ?? -1;\n\n  return function handleKeyDown(event: React.KeyboardEvent) {\n    if (\n      ![\n        \"ArrowDown\",\n        \"ArrowUp\",\n        \"ArrowLeft\",\n        \"ArrowRight\",\n        \"PageUp\",\n        \"PageDown\",\n        \"Home\",\n        \"End\",\n      ].includes(event.key)\n    ) {\n      return;\n    }\n\n    // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n    let selectableDescendants = filter\n      ? descendants.filter(filter)\n      : descendants;\n\n    // Current index should map to the updated array vs. the original\n    // descendants array.\n    if (filter) {\n      index = selectableDescendants.findIndex(\n        descendant => descendant.index === currentIndex\n      );\n    }\n\n    // We need some options for any of this to work!\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    function getNextOption() {\n      let atBottom = index === selectableDescendants.length - 1;\n      return atBottom\n        ? rotate\n          ? getFirstOption()\n          : selectableDescendants[index]\n        : selectableDescendants[(index + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      let atTop = index === 0;\n      return atTop\n        ? rotate\n          ? getLastOption()\n          : selectableDescendants[index]\n        : selectableDescendants[\n            (index - 1 + selectableDescendants.length) %\n              selectableDescendants.length\n          ];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          let next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n        break;\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          let prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n        break;\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          let nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n        break;\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          let prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n        break;\n      case \"PageUp\":\n        event.preventDefault();\n        let prevOrFirst = (event.ctrlKey\n          ? getPreviousOption\n          : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n      case \"Home\":\n        event.preventDefault();\n        let first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n      case \"PageDown\":\n        event.preventDefault();\n        let nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n      case \"End\":\n        event.preventDefault();\n        let last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype SomeHTMLElement<T> = T extends HTMLElement ? T : HTMLElement;\n\nexport type Descendant<ElementType, DescendantProps = {}> = DescendantProps & {\n  element: SomeHTMLElement<ElementType> | null;\n  index: number;\n};\n\nexport interface IDescendantContext<ElementType, DescendantProps> {\n  descendants: Descendant<ElementType, DescendantProps>[];\n  registerDescendant(\n    descendant: Descendant<ElementType, DescendantProps>\n  ): void;\n  unregisterDescendant(element: SomeHTMLElement<ElementType> | null): void;\n}\n"],"names":["Ctx","context","children","items","set","registerDescendant","React","useCallback","element","rest","newItem","newItems","length","index","find","item","findIndex","Boolean","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","slice","map","unregisterDescendant","filter","value","useMemo","descendants","Provider","name","initialValue","createNamedContext","noop","indexProp","forceUpdate","useState","useContext","useIsomorphicLayoutEffect","Object","values","options","callback","currentIndex","key","orientation","rotate","rtl","event","includes","selectableDescendants","descendant","preventDefault","next","getNextOption","prev","getPreviousOption","nextOrPrev","prevOrNext","prevOrFirst","ctrlKey","getFirstOption","first","nextOrLast","getLastOption","last"],"mappings":"4iBA0EWA,IAATC,QACAC,IAAAA,SACAC,IAAAA,MACAC,IAAAA,IASIC,EAAqBC,EAAMC,aAC7B,gBAAGC,IAAAA,QAAYC,mBACRD,GAILJ,GAAI,SAAAD,OACEO,EACAC,KAEiB,IAAjBR,EAAMS,OACRF,KACEF,QAAAA,EACAK,MAAO,GACJJ,GAELE,YAAeR,GAAOO,SACjB,GAAIP,EAAMW,MAAK,SAAAC,UAAQA,EAAKP,UAAYA,KAE7CG,EAAWR,MACN,KAaDU,EAAQV,EAAMa,WAAU,SAAAD,YACrBA,EAAKP,UAAYA,IAOfS,QACLF,EAAKP,QAAQU,wBAAwBV,GACnCW,KAAKC,gCAIXV,KACEF,QAAAA,EACAK,MAAAA,GACGJ,GAKHE,GADa,IAAXE,YACaV,GAAOO,cAGjBP,EAAMkB,MAAM,EAAGR,IAClBH,GACGP,EAAMkB,MAAMR,WAIdF,EAASW,KAAI,SAACP,EAAMF,eAAgBE,GAAMF,MAAAA,gBAUnDU,EAAuBhB,eACzB,SAACC,GACMA,GAILJ,GAAI,SAAAD,UAASA,EAAMqB,QAAO,SAAAT,UAAQP,IAAYO,EAAKP,oBASjDiB,EAGFC,WAAQ,iBACH,CACLC,YAAaxB,EACbE,mBAAAA,EACAkB,qBAAAA,KAED,CAACpB,EAAOE,EAAoBkB,WAExBjB,gBAACN,EAAI4B,UAASH,MAAOA,GAAQvB,6CAlLpC2B,EACAC,mBAAAA,IAAAA,EAAe,IAERC,qBAAmBF,KACxBF,YAAa,GACbtB,mBAAoB2B,OACpBT,qBAAsBS,QACnBF,sCAmCLG,OANEhC,IAAAA,QACAO,IAAAA,QACGC,6BAMEyB,EAAeC,kBAC0CC,aAC9DnC,GADII,IAAAA,mBAAoBkB,IAAAA,qBAAsBI,IAAAA,mBAKhDU,6BAA0B,kBACnB7B,GAAS0B,EAAY,IAE1B7B,KAAqBG,QAAAA,GAAYC,IAC1B,kBAAMc,EAAqBf,OAEhCA,UAAY8B,OAAOC,OAAO9B,KAEvBwB,MAAAA,EAAAA,EAAaN,EAAYX,WAAU,SAAAD,UAAQA,EAAKP,UAAYA,4CAgJnEP,EACAuC,OAcMb,EAAgBS,aAAWnC,GAA3B0B,YAEJc,EAOED,EAPFC,SACAC,EAMEF,EANFE,aACAlB,EAKEgB,EALFhB,SAKEgB,EAJFG,IAAAA,aAAM,YAIJH,EAHFI,YAAAA,aAAc,eAGZJ,EAFFK,OAAAA,kBAEEL,EADFM,IAAAA,gBAEEjC,EAAQ6B,MAAAA,EAAAA,GAAiB,SAEtB,SAAuBK,MAEzB,CACC,YACA,UACA,YACA,aACA,SACA,WACA,OACA,OACAC,SAASD,EAAMJ,UAOfM,EAAwBzB,EACxBG,EAAYH,OAAOA,GACnBG,KAIAH,IACFX,EAAQoC,EAAsBjC,WAC5B,SAAAkC,UAAcA,EAAWrC,QAAU6B,MAKlCO,EAAsBrC,cAiCnBmC,EAAMJ,SACP,eACiB,aAAhBC,GAA8C,SAAhBA,EAAwB,CACxDG,EAAMI,qBACFC,EAAOC,IACXZ,EAAiB,WAARE,EAAmBS,EAAOA,EAAKT,cAGvC,aACiB,aAAhBC,GAA8C,SAAhBA,EAAwB,CACxDG,EAAMI,qBACFG,EAAOC,IACXd,EAAiB,WAARE,EAAmBW,EAAOA,EAAKX,cAGvC,eACiB,eAAhBC,GAAgD,SAAhBA,EAAwB,CAC1DG,EAAMI,qBACFK,GAAcV,EAAMO,EAAgBE,KACxCd,EAAiB,WAARE,EAAmBa,EAAaA,EAAWb,cAGnD,gBACiB,eAAhBC,GAAgD,SAAhBA,EAAwB,CAC1DG,EAAMI,qBACFM,GAAcX,EAAMS,EAAoBF,KAC5CZ,EAAiB,WAARE,EAAmBc,EAAaA,EAAWd,cAGnD,SACHI,EAAMI,qBACFO,GAAeX,EAAMY,QACrBJ,EACAK,KACJnB,EAAiB,WAARE,EAAmBe,EAAcA,EAAYf,cAEnD,OACHI,EAAMI,qBACFU,EAAQD,IACZnB,EAAiB,WAARE,EAAmBkB,EAAQA,EAAMlB,cAEvC,WACHI,EAAMI,qBACFW,GAAcf,EAAMY,QAAUN,EAAgBU,KAClDtB,EAAiB,WAARE,EAAmBmB,EAAaA,EAAWnB,cAEjD,MACHI,EAAMI,qBACFa,EAAOD,IACXtB,EAAiB,WAARE,EAAmBqB,EAAOA,EAAKrB,cA9EnCU,WACQxC,IAAUoC,EAAsBrC,OAAS,EAEpDiC,EACEe,IACAX,EAAsBpC,GACxBoC,GAAuBpC,EAAQ,GAAKoC,EAAsBrC,iBAGvD2C,WACe,IAAV1C,EAERgC,EACEkB,IACAd,EAAsBpC,GACxBoC,GACGpC,EAAQ,EAAIoC,EAAsBrC,QACjCqC,EAAsBrC,iBAIvBgD,WACAX,EAAsB,YAGtBc,WACAd,EAAsBA,EAAsBrC,OAAS,+CApOzDuB,WAAqD"}