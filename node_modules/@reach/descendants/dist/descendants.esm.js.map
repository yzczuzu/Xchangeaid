{"version":3,"file":"descendants.esm.js","sources":["../src/index.tsx"],"sourcesContent":["import React, { useCallback, useContext, useMemo, useState } from \"react\";\nimport {\n  createNamedContext,\n  noop,\n  useIsomorphicLayoutEffect,\n} from \"@reach/utils\";\n\nexport function createDescendantContext<ElementType, DescendantProps = {}>(\n  name: string,\n  initialValue = {}\n) {\n  return createNamedContext(name, {\n    descendants: [],\n    registerDescendant: noop,\n    unregisterDescendant: noop,\n    ...initialValue,\n  } as IDescendantContext<ElementType, DescendantProps>);\n}\n\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\nexport function useDescendant<ElementType, DescendantProps>(\n  {\n    context,\n    element,\n    ...rest\n  }: Omit<Descendant<ElementType, DescendantProps>, \"index\"> & {\n    context: React.Context<IDescendantContext<ElementType, DescendantProps>>;\n  },\n  indexProp?: number\n) {\n  let [, forceUpdate] = useState();\n  let { registerDescendant, unregisterDescendant, descendants } = useContext(\n    context\n  );\n\n  // Prevent any flashing\n  useIsomorphicLayoutEffect(() => {\n    if (!element) forceUpdate({});\n    // @ts-ignore\n    registerDescendant({ element, ...rest });\n    return () => unregisterDescendant(element);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [element, ...Object.values(rest)]);\n\n  return indexProp ?? descendants.findIndex(item => item.element === element);\n}\n\nexport function useDescendants<ElementType, DescendantProps = {}>() {\n  return useState<Descendant<ElementType, DescendantProps>[]>([]);\n}\n\nexport function DescendantProvider<ElementType, DescendantProps>({\n  context: Ctx,\n  children,\n  items,\n  set,\n}: {\n  context: React.Context<IDescendantContext<ElementType, DescendantProps>>;\n  children: React.ReactNode;\n  items: Descendant<ElementType, DescendantProps>[];\n  set: React.Dispatch<\n    React.SetStateAction<Descendant<ElementType, DescendantProps>[]>\n  >;\n}) {\n  let registerDescendant = React.useCallback(\n    ({ element, ...rest }: Descendant<ElementType, DescendantProps>) => {\n      if (!element) {\n        return;\n      }\n\n      set(items => {\n        let newItem: Descendant<ElementType, DescendantProps>;\n        let newItems: Descendant<ElementType, DescendantProps>[];\n        // If there are no items, register at index 0 and bail.\n        if (items.length === 0) {\n          newItem = {\n            element,\n            index: 0,\n            ...rest,\n          } as Descendant<ElementType, DescendantProps>;\n          newItems = [...items, newItem];\n        } else if (items.find(item => item.element === element)) {\n          // If the element is already registered, just use the same array\n          newItems = items;\n        } else {\n          // When registering a descendant, we need to make sure we insert in\n          // into the array in the same order that it appears in the DOM. So as\n          // new descendants are added or maybe some are removed, we always know\n          // that the array is up-to-date and correct.\n          //\n          // So here we look at our registered descendants and see if the new\n          // element we are adding appears earlier than an existing descendant's\n          // DOM node via `node.compareDocumentPosition`. If it does, we insert\n          // the new element at this index. Because `registerDescendant` will be\n          // called in an effect every time the descendants state value changes,\n          // we should be sure that this index is accurate when descendent\n          // elements come or go from our component.\n          let index = items.findIndex(item => {\n            if (!item.element || !element) {\n              return false;\n            }\n            // Does this element's DOM node appear before another item in the\n            // array in our DOM tree? If so, return true to grab the index at\n            // this point in the array so we know where to insert the new\n            // element.\n            return Boolean(\n              item.element.compareDocumentPosition(element) &\n                Node.DOCUMENT_POSITION_PRECEDING\n            );\n          });\n\n          newItem = {\n            element,\n            index,\n            ...rest,\n          } as Descendant<ElementType, DescendantProps>;\n\n          // If an index is not found we will push the element to the end.\n          if (index === -1) {\n            newItems = [...items, newItem];\n          } else {\n            newItems = [\n              ...items.slice(0, index),\n              newItem,\n              ...items.slice(index),\n            ];\n          }\n        }\n        return newItems.map((item, index) => ({ ...item, index }));\n      });\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  let unregisterDescendant = useCallback(\n    (element: Descendant<ElementType>[\"element\"]) => {\n      if (!element) {\n        return;\n      }\n\n      set(items => items.filter(item => element !== item.element));\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const value: IDescendantContext<\n    ElementType,\n    DescendantProps\n  > = useMemo(() => {\n    return {\n      descendants: items,\n      registerDescendant,\n      unregisterDescendant,\n    };\n  }, [items, registerDescendant, unregisterDescendant]);\n\n  return <Ctx.Provider value={value}>{children}</Ctx.Provider>;\n}\n\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\nexport function useDescendantKeyDown<\n  ElementType,\n  DescendantProps = {},\n  K extends keyof Descendant<ElementType, DescendantProps> = keyof Descendant<\n    ElementType,\n    DescendantProps\n  >\n>(\n  context: React.Context<IDescendantContext<ElementType, DescendantProps>>,\n  options: {\n    currentIndex: number | null | undefined;\n    key?: K | \"option\";\n    filter?: (descendant: Descendant<ElementType, DescendantProps>) => boolean;\n    orientation?: \"vertical\" | \"horizontal\" | \"both\";\n    rotate?: boolean;\n    rtl?: boolean;\n    callback(\n      nextOption:\n        | Descendant<ElementType, DescendantProps>\n        | Descendant<ElementType, DescendantProps>[K]\n    ): void;\n  }\n) {\n  let { descendants } = useContext(context);\n  let {\n    callback,\n    currentIndex,\n    filter,\n    key = \"index\" as K,\n    orientation = \"vertical\",\n    rotate = true,\n    rtl = false,\n  } = options;\n  let index = currentIndex ?? -1;\n\n  return function handleKeyDown(event: React.KeyboardEvent) {\n    if (\n      ![\n        \"ArrowDown\",\n        \"ArrowUp\",\n        \"ArrowLeft\",\n        \"ArrowRight\",\n        \"PageUp\",\n        \"PageDown\",\n        \"Home\",\n        \"End\",\n      ].includes(event.key)\n    ) {\n      return;\n    }\n\n    // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n    let selectableDescendants = filter\n      ? descendants.filter(filter)\n      : descendants;\n\n    // Current index should map to the updated array vs. the original\n    // descendants array.\n    if (filter) {\n      index = selectableDescendants.findIndex(\n        descendant => descendant.index === currentIndex\n      );\n    }\n\n    // We need some options for any of this to work!\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    function getNextOption() {\n      let atBottom = index === selectableDescendants.length - 1;\n      return atBottom\n        ? rotate\n          ? getFirstOption()\n          : selectableDescendants[index]\n        : selectableDescendants[(index + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      let atTop = index === 0;\n      return atTop\n        ? rotate\n          ? getLastOption()\n          : selectableDescendants[index]\n        : selectableDescendants[\n            (index - 1 + selectableDescendants.length) %\n              selectableDescendants.length\n          ];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          let next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n        break;\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          let prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n        break;\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          let nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n        break;\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          let prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n        break;\n      case \"PageUp\":\n        event.preventDefault();\n        let prevOrFirst = (event.ctrlKey\n          ? getPreviousOption\n          : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n      case \"Home\":\n        event.preventDefault();\n        let first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n      case \"PageDown\":\n        event.preventDefault();\n        let nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n      case \"End\":\n        event.preventDefault();\n        let last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype SomeHTMLElement<T> = T extends HTMLElement ? T : HTMLElement;\n\nexport type Descendant<ElementType, DescendantProps = {}> = DescendantProps & {\n  element: SomeHTMLElement<ElementType> | null;\n  index: number;\n};\n\nexport interface IDescendantContext<ElementType, DescendantProps> {\n  descendants: Descendant<ElementType, DescendantProps>[];\n  registerDescendant(\n    descendant: Descendant<ElementType, DescendantProps>\n  ): void;\n  unregisterDescendant(element: SomeHTMLElement<ElementType> | null): void;\n}\n"],"names":["createDescendantContext","name","initialValue","createNamedContext","descendants","registerDescendant","noop","unregisterDescendant","useDescendant","indexProp","context","element","rest","useState","forceUpdate","useContext","useIsomorphicLayoutEffect","Object","values","findIndex","item","useDescendants","DescendantProvider","Ctx","children","items","set","React","useCallback","newItem","newItems","length","index","find","Boolean","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","slice","map","filter","value","useMemo","Provider","useDescendantKeyDown","options","callback","currentIndex","key","orientation","rotate","rtl","handleKeyDown","event","includes","selectableDescendants","descendant","getNextOption","atBottom","getFirstOption","getPreviousOption","atTop","getLastOption","preventDefault","next","prev","nextOrPrev","prevOrNext","prevOrFirst","ctrlKey","first","nextOrLast","last"],"mappings":"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"}